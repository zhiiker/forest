initSidebarItems({"constant":[["ADDRESSED_PARTITIONS_MAX",""],["ADDRESSED_SECTORS_MAX",""],["CHAIN_FINALITY","Epochs after which chain state is final."],["CRON_EVENT_PROCESS_EARLY_TERMINATIONS",""],["CRON_EVENT_PROVING_DEADLINE",""],["CRON_EVENT_WORKER_KEY_CHANGE",""],["DEAL_LIMIT_DENOMINATOR","Ratio of sector size to maximum deals per sector. The maximum number of deals is the sector size divided by this number (2^27) which limits 32GiB sectors to 256 deals and 64GiB sectors to 512"],["DECLARED_FAULT_PROJECTION_PERIOD_V0",""],["DECLARED_FAULT_PROJECTION_PERIOD_V3",""],["ELECTION_LOOKBACK","Lookback from the current epoch for state view for leader elections."],["FAULT_DECLARATION_CUTOFF","Minimum period before a deadline's challenge window opens that a fault must be declared for that deadline. This lookback must not be less than WPoStChallengeLookback lest a malicious miner be able to selectively declare faults after learning the challenge value."],["FAULT_MAX_AGE","The maximum age of a fault before the sector is terminated."],["INITIAL_PLEDGE_PROJECTION_PERIOD",""],["MAX_SECTOR_EXPIRATION_EXTENSION","Maximum number of epochs past the current epoch a sector may be set to expire. The actual maximum extension will be the minimum of CurrEpoch + MaximumSectorExpirationExtension and sector.ActivationEpoch+sealProof.SectorMaximumLifetime()"],["MIN_SECTOR_EXPIRATION","Minimum number of epochs past the current epoch a sector may be set to expire."],["NEW_SECTORS_PER_PERIOD_MAX","The maximum number of new sectors that may be staged by a miner during a single proving period."],["PRE_COMMIT_CHALLENGE_DELAY","Number of epochs between publishing the precommit and when the challenge for interactive PoRep is drawn used to ensure it is not predictable by miner."],["PRE_COMMIT_DEPOSIT_PROJECTION_PERIOD",""],["REWARD_VESTING_SPEC_V0",""],["REWARD_VESTING_SPEC_V1",""],["SEALED_CID_PREFIX",""],["SECTORS_MAX",""],["TERMINATION_LIFETIME_CAP",""],["UNDECLARED_FAULT_PROJECTION_PERIOD_V0",""],["UNDECLARED_FAULT_PROJECTION_PERIOD_V1",""],["WORKER_KEY_CHANGE_DELAY","Staging period for a miner worker key change. Finality is a harsh delay for a miner who has lost their worker key, as the miner will miss Window PoSts until it can be changed. It's the only safe value, though. We may implement a mitigation mechanism such as a second key or allowing the owner account to submit PoSts while a key change is pending."],["WPOST_CHALLENGE_LOOKBACK","Lookback from the deadline's challenge window opening from which to sample chain randomness for the challenge seed. This lookback exists so that deadline windows can be non-overlapping (which make the programming simpler) but without making the miner wait for chain stability before being able to start on PoSt computation. The challenge is available this many epochs before the window is actually open to receiving a PoSt."],["WPOST_CHALLENGE_WINDOW","The duration of a deadline's challenge window, the period before a deadline when the challenge is available."],["WPOST_MAX_CHAIN_COMMIT_AGE","The maximum distance back that a valid Window PoSt must commit to the current chain."],["WPOST_PERIOD_DEADLINES","The number of non-overlapping PoSt deadlines in each proving period."],["WPOST_PROVING_PERIOD","The period over which all a miner's active sectors will be challenged."]],"enum":[["Method","Storage Miner actor methods available"]],"fn":[["assign_deadlines",""],["check_supported_proof_types","List of proof types which can be used when creating new miner actors"],["deadline_is_mutable","Returns true if the deadline at the given index is currently mutable."],["deal_per_sector_limit","Determine maximum number of deal miner's sector can hold"],["expected_reward_for_power","This is the BR(t) value of the given sector for the current epoch. It is the expected reward this sector would pay out over a one day period. BR(t) = CurrEpochReward(t) * SectorQualityAdjustedPower * EpochsInDay / TotalNetworkQualityAdjustedPower(t)"],["initial_pledge_for_power",""],["load_partitions_sectors_max","The maximum number of partitions that may be required to be loaded in a single invocation, when all the sector infos for the partitions will be loaded."],["max_seal_duration","Maximum duration to allow for the sealing process for seal algorithms. Dependent on algorithm and sector size"],["new_deadline_info",""],["pledge_penalty_for_declared_fault",""],["pledge_penalty_for_termination","Penalty to locked pledge collateral for the termination of a sector before scheduled expiry. SectorAge is the time between the sector's activation and termination."],["pledge_penalty_for_undeclared_fault","This is the SP(t) penalty for a newly faulty sector that has not been declared. SP(t) = UndeclaredFaultFactor * BR(t)"],["pre_commit_deposit_for_power","Computes the PreCommit Deposit given sector qa weight and current network conditions. PreCommit Deposit = 20 * BR(t)"],["qa_power_for_sector","Returns the quality-adjusted power for a sector."],["qa_power_for_weight","Returns the power for a sector size and weight."],["reward_for_consensus_slash_report",""]],"struct":[["Actor","Miner Actor"],["ApplyRewardParams",""],["BitFieldQueue","Wrapper for working with an AMT[ChainEpoch]*Bitfield functioning as a queue, bucketed by epoch. Keys in the queue are quantized (upwards), modulo some offset, to reduce the cardinality of keys."],["ChainSectorInfo",""],["ChangeMultiaddrsParams",""],["ChangePeerIDParams",""],["ChangeWorkerAddressParams",""],["CheckSectorProvenParams",""],["CompactPartitionsParams",""],["CompactSectorNumbersParams",""],["ConfirmSectorProofsParams",""],["CronEventPayload",""],["Deadline","Deadline holds the state for all sectors due at a specific deadline."],["DeadlineSectorMap","Maps deadlines to partition maps."],["Deadlines","Deadlines contains Deadline objects, describing the sectors due at the given deadline and their state (faulty, terminated, recovering, etc.)."],["DeclareFaultsParams",""],["DeclareFaultsRecoveredParams",""],["ExpirationExtension",""],["ExpirationQueue","A queue of expiration sets by epoch, representing the on-time or early termination epoch for a collection of sectors. Wraps an AMT[ChainEpoch]*ExpirationSet. Keys in the queue are quantized (upwards), modulo some offset, to reduce the cardinality of keys."],["ExpirationSet","ExpirationSet is a collection of sector numbers that are expiring, either due to expected \"on-time\" expiration at the end of their life, or unexpected \"early\" termination due to being faulty for too long consecutively. Note that there is not a direct correspondence between on-time sectors and active power; a sector may be faulty but expiring on-time if it faults just prior to expected termination. Early sectors are always faulty, and active power always represents on-time sectors."],["ExtendSectorExpirationParams",""],["Fault",""],["FaultDeclaration",""],["GetControlAddressesReturn",""],["MinerConstructorParams","Storage miner actor constructor params are defined here so the power actor can send them to the init actor to instantiate miners."],["MinerInfo","Static information about miner"],["Partition",""],["PartitionKey",""],["PartitionSectorMap","Maps partitions to sector bitfields."],["PoStPartition",""],["PoStResult",""],["PowerPair",""],["ProveCommitSectorParams",""],["RecoveryDeclaration",""],["ReportConsensusFaultParams",""],["SectorOnChainInfo","Information stored on-chain for a proven sector."],["SectorPreCommitInfo",""],["SectorPreCommitOnChainInfo","Information stored on-chain for a pre-committed sector."],["Sectors",""],["State","Balance of Miner Actor should be greater than or equal to the sum of PreCommitDeposits and LockedFunds. It is possible for balance to fall below the sum of PCD, LF and InitialPledgeRequirements, and this is a bad state (IP Debt) that limits a miner actor's behavior (i.e. no balance withdrawals) Excess balance as computed by st.GetAvailableBalance will be withdrawable or usable for pre-commit deposit or pledge lock-up."],["SubmitWindowedPoStParams","Information submitted by a miner to provide a Window PoSt."],["TerminateSectorsParams",""],["TerminateSectorsReturn",""],["TerminationDeclaration",""],["TerminationResult",""],["VestSpec","Specification for a linear vesting schedule."],["VestingFund",""],["VestingFunds","Represents the vesting table state for the miner. It is a slice of (VestingEpoch, VestingAmount). The slice will always be sorted by the VestingEpoch."],["WithdrawBalanceParams",""],["WorkerKeyChange",""]],"type":[["CronEvent",""]]});